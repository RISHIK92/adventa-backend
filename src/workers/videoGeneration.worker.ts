import { Worker, Job } from "bullmq";
import { PrismaClient } from "@prisma/client";
import { exec } from "child_process";
import util from "util";
import fs from "fs/promises";
import path from "path";
import "dotenv/config";
import { getQuestionDetailsFromMCP } from "../utils/getQuestionDetailsFromMCP.js";
import { generateManimScriptWithGemini } from "../utils/generateManimScriptWithGemini.js";
import { debugManimScriptWithGemini } from "../utils/debugManimScriptWithGemini.js";
import { YouTubeUploadService } from "../services/youtubeUpload.js";

const execPromise = util.promisify(exec);
const prisma = new PrismaClient();
const youtubeService = await YouTubeUploadService.create();

const connection = {
  host: process.env.REDIS_HOST || "localhost",
  port: parseInt(process.env.REDIS_PORT || "6379"),
  password: process.env.REDIS_PASSWORD || "myStrongPassword",
};

const MAX_RETRIES = 4;

/**
 * Check if a file exists and has reasonable size
 */
const validateFile = async (
  filePath: string,
  minSize: number = 1000
): Promise<void> => {
  try {
    const stats = await fs.stat(filePath);
    if (stats.size < minSize) {
      throw new Error(`File ${filePath} is too small (${stats.size} bytes)`);
    }
    console.log(
      `[Validation] File ${filePath}: ${(stats.size / 1024 / 1024).toFixed(
        2
      )} MB`
    );
  } catch (error: any) {
    throw new Error(`File validation failed for ${filePath}: ${error.message}`);
  }
};

/**
 * Enhanced command execution with timeout
 */
const execWithTimeout = async (
  command: string,
  timeoutMs: number = 300000
): Promise<{ stdout: string; stderr: string }> => {
  console.log(`[Exec] Running: ${command}`);

  try {
    const result = await Promise.race([
      execPromise(command),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error(`Command timeout after ${timeoutMs}ms`)),
          timeoutMs
        )
      ),
    ]);

    console.log(`[Exec] Command completed successfully`);
    return result;
  } catch (error: any) {
    const errorMessage =
      error.stderr || error.stdout || error.message || "Unknown error";
    console.error(`[Exec] Command failed: ${errorMessage}`);
    throw new Error(`Command failed: ${errorMessage}`);
  }
};

/**
 * Generate video title and description for YouTube
 */
const generateYouTubeMetadata = (questionDetails: any, scriptResponse: any) => {
  const title = `${
    questionDetails.title || "Educational Video"
  } - AI Generated Explanation`;

  const description = `
${scriptResponse.description}

üìö This educational video was automatically generated to explain complex concepts through visual animations.

üéØ Topic: ${questionDetails.subject || "Mathematics"}
‚è±Ô∏è Auto-generated content
ü§ñ Created with AI assistance

#Education #Learning #Mathematics #AI #Animation #Tutorial

---
Generated by Adventa AI Education Platform
`.trim();

  const tags = [
    "education",
    "learning",
    "mathematics",
    "tutorial",
    "ai",
    "animation",
    "explanation",
    questionDetails.subject?.toLowerCase(),
    questionDetails.topic?.toLowerCase(),
  ].filter(Boolean);

  return { title, description, tags };
};

// --- Main Worker Logic ---
const worker = new Worker(
  "video-generation",
  async (
    job: Job<{ jobId: string; questionId: number; uploadToYouTube?: boolean }>
  ) => {
    const { jobId, questionId, uploadToYouTube = true } = job.data;
    const TEMP_DIR = path.join(process.cwd(), "temp", jobId);

    console.log(`[Worker] Processing job ${jobId} for question ${questionId}`);

    try {
      await fs.rm(TEMP_DIR, { recursive: true, force: true });
      await fs.mkdir(TEMP_DIR, { recursive: true });

      await prisma.videoGenerationJob.update({
        where: { id: jobId },
        data: { status: "PROCESSING" },
      });

      let jobRecord = await prisma.videoGenerationJob.findUnique({
        where: { id: jobId },
      });
      let lastManimCode = "";

      for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        await job.updateProgress({ step: `Attempt ${attempt}/${MAX_RETRIES}` });

        try {
          // --- Step 1 & 2: Get Details & Generate Script ---
          const questionDetails = await getQuestionDetailsFromMCP(questionId);

          if (!questionDetails) {
            throw new Error(`Question ID ${questionId} not found in MCP.`);
          }

          let scriptResponse;
          if (attempt === 1) {
            console.log(`[Job ${jobId}] Generating initial script...`);
            scriptResponse = await generateManimScriptWithGemini(
              questionDetails
            );
          } else {
            console.log(`[Job ${jobId}] Attempting to debug previous error...`);
            // On a retry, the previous error message and failed code are in the jobRecord
            const lastError = jobRecord?.errorMessage || "Unknown Manim error";
            scriptResponse = await debugManimScriptWithGemini(
              questionDetails,
              lastManimCode,
              lastError
            );
          }

          lastManimCode = scriptResponse.manimCode;
          const SCENE_NAME = scriptResponse.className;

          jobRecord = await prisma.videoGenerationJob.update({
            where: { id: jobId },
            data: {
              manimCode: lastManimCode,
              description: scriptResponse.description,
              retryCount: attempt - 1,
            },
          });

          // --- Step 3: Render Manim Video ---
          await job.updateProgress({ step: "Rendering video animation..." });
          const scriptPath = path.join(TEMP_DIR, `${SCENE_NAME}.py`);
          await fs.writeFile(scriptPath, lastManimCode);
          const manimOutputDir = path.join(TEMP_DIR, "media");
          const manimCommand = `manim -qh --media_dir "${manimOutputDir}" "${scriptPath}"`;
          await execWithTimeout(manimCommand, 180000); // 3 mins
          const rawVideoPath = path.join(
            manimOutputDir,
            "videos",
            SCENE_NAME,
            "1080p60",
            `${SCENE_NAME}.mp4`
          );
          await validateFile(rawVideoPath, 50000);
          console.log(`[Job ${jobId}] Manim render complete: ${rawVideoPath}`);
          const finalVideoPath = path.join(TEMP_DIR, `${jobId}_final.mp4`);

          const durationProbe = await execPromise(
            `ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "${rawVideoPath}"`
          );
          const videoDurationString = durationProbe.stdout.trim();

          // 2. Parse the string into a number (THE FIX)
          const videoDuration = parseFloat(videoDurationString);
          if (isNaN(videoDuration)) {
            throw new Error(
              `Failed to parse video duration from ffprobe: ${videoDurationString}`
            );
          }

          const fadeOutStartTime = Math.max(0, videoDuration - 5);

          // 4. Build the final ffmpeg command string
          const ffmpegCommand = [
            "ffmpeg",
            "-y", // Overwrite output file if it exists
            "-i", // Specify the input file
            `"${rawVideoPath}"`,
            "-c:v", // Set the video codec
            "libx264", // Use the standard H.264 codec
            "-preset", // Set the encoding speed/quality balance
            "medium",
            "-crf", // Set the quality level (Constant Rate Factor)
            "23",
            "-an", // No Audio (strips any audio track)
            `"${finalVideoPath}"`,
          ].join(" ");

          await execWithTimeout(ffmpegCommand, 120000); // 2 mins
          await validateFile(finalVideoPath, 50000);
          console.log(`[Job ${jobId}] Final video created: ${finalVideoPath}`);

          // --- Step 6 & 7: Upload and Finalize ---
          let finalUrl: string;
          let videoId: string | null = null;

          if (uploadToYouTube) {
            await job.updateProgress({ step: "Uploading to YouTube..." });

            // --- Step 6: Upload to YouTube ---
            try {
              const { title, description, tags } = generateYouTubeMetadata(
                questionDetails,
                scriptResponse
              );

              const youtubeResult = await youtubeService.uploadVideo(
                finalVideoPath,
                {
                  title: title.substring(0, 100), // YouTube title limit
                  description: description.substring(0, 5000), // YouTube description limit
                  tags: tags.slice(0, 15), // YouTube tags limit
                  categoryId: "27", // Education
                  privacyStatus: "unlisted", // Safe default
                }
              );

              finalUrl = youtubeResult.watchUrl;
              videoId = youtubeResult.videoId;

              console.log(
                `[Job ${jobId}] YouTube upload successful: ${finalUrl}`
              );

              // Wait for YouTube processing
              await job.updateProgress({ step: "YouTube processing..." });

              let processingComplete = false;
              let attempts = 0;
              const maxProcessingChecks = 10;

              while (!processingComplete && attempts < maxProcessingChecks) {
                await new Promise((resolve) => setTimeout(resolve, 10000)); // Wait 10 seconds

                try {
                  const status = await youtubeService.checkVideoStatus(
                    youtubeResult.videoId
                  );
                  console.log(
                    `[YouTube] Processing status: ${status.processingStatus}`
                  );

                  if (
                    status.processingStatus === "succeeded" ||
                    status.uploadStatus === "processed"
                  ) {
                    processingComplete = true;
                  } else if (status.processingStatus === "failed") {
                    throw new Error("YouTube processing failed");
                  }
                } catch (statusError: any) {
                  console.warn(
                    `[YouTube] Status check failed: ${statusError.message}`
                  );
                }

                attempts++;
              }
            } catch (youtubeError: any) {
              console.error(
                `[Job ${jobId}] YouTube upload failed: ${youtubeError.message}`
              );

              // Fall back to local file path or throw error based on requirements
              if (
                youtubeError.message.includes("quota") ||
                youtubeError.message.includes("limit")
              ) {
                throw new Error(
                  `YouTube upload failed: ${youtubeError.message}. Please try again later.`
                );
              } else {
                throw youtubeError;
              }
            }
          } else {
            // Keep local file path if not uploading to YouTube
            finalUrl = finalVideoPath;
          }
          await prisma.videoGenerationJob.update({
            where: { id: jobId },
            data: {
              status: "COMPLETED",
              videoUrl: finalUrl,
              errorMessage: null,
            },
          });

          console.log(
            `[Worker] Job ${jobId} completed successfully: ${finalUrl}`
          );
          return { success: true, url: finalUrl };
        } catch (stepError: any) {
          const errorMessage = stepError.message || stepError.toString();
          console.error(
            `[Job ${jobId}] Attempt ${attempt} failed:`,
            errorMessage
          );
          await prisma.videoGenerationJob.update({
            where: { id: jobId },
            data: { errorMessage, retryCount: attempt },
          });
          if (attempt >= MAX_RETRIES) throw stepError;
          await new Promise((resolve) => setTimeout(resolve, 5000));
        }
      }
    } catch (finalError: any) {
      console.error(
        `[Worker] Job ${jobId} permanently failed:`,
        finalError.message
      );
      await prisma.videoGenerationJob.update({
        where: { id: jobId },
        data: { status: "FAILED", errorMessage: finalError.message },
      });
      throw finalError;
    } finally {
      console.log(`[Job ${jobId}] Cleaning up: ${TEMP_DIR}`);
      await fs
        .rm(TEMP_DIR, { recursive: true, force: true })
        .catch((err) => console.warn(`Cleanup warning: ${err.message}`));
    }
  },
  { connection, concurrency: 1 }
);

worker.on("completed", (job) =>
  console.log(`[Worker] ‚úÖ Job ${job.id} completed.`)
);
worker.on("failed", (job, err) =>
  console.error(`[Worker] ‚ùå Job ${job?.id} failed: ${err.message}`)
);

worker.on("progress", (job, progress) => {
  console.log(`[Worker] üìä Job ${job.id} progress:`, progress);
});

// Graceful shutdown
process.on("SIGTERM", async () => {
  console.log("Shutting down worker gracefully...");
  await worker.close();
});

console.log("üöÄ Video generation worker with YouTube upload started!");
