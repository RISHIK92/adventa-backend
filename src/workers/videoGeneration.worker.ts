import { Worker, Job } from "bullmq";
import { PrismaClient } from "@prisma/client";
import { exec } from "child_process";
import util from "util";
import fs from "fs/promises";
import path from "path";
import "dotenv/config";
import { getQuestionDetailsFromMCP } from "../utils/getQuestionDetailsFromMCP.js";
import { generateManimScriptWithGemini } from "../utils/generateManimScriptWithGemini.js";
import { debugManimScriptWithGemini } from "../utils/debugManimScriptWithGemini.js";
import { YouTubeUploadService } from "../services/youtubeUpload.js";

const execPromise = util.promisify(exec);
const prisma = new PrismaClient();
const youtubeService = new YouTubeUploadService();

const connection = {
  host: process.env.REDIS_HOST || "localhost",
  port: parseInt(process.env.REDIS_PORT || "6379"),
  password: process.env.REDIS_PASSWORD || "myStrongPassword",
};

const MAX_RETRIES = 4;

/**
 * Check if a file exists and has reasonable size
 */
const validateFile = async (
  filePath: string,
  minSize: number = 1000
): Promise<void> => {
  try {
    const stats = await fs.stat(filePath);
    if (stats.size < minSize) {
      throw new Error(`File ${filePath} is too small (${stats.size} bytes)`);
    }
    console.log(
      `[Validation] File ${filePath}: ${(stats.size / 1024 / 1024).toFixed(
        2
      )} MB`
    );
  } catch (error: any) {
    throw new Error(`File validation failed for ${filePath}: ${error.message}`);
  }
};

/**
 * Generate thumbnail from video
 */
const generateThumbnail = async (
  videoPath: string,
  thumbnailPath: string
): Promise<void> => {
  try {
    const command = `ffmpeg -y -i "${videoPath}" -ss 00:00:02 -vframes 1 -q:v 2 "${thumbnailPath}"`;
    await execPromise(command);
    console.log(`[Thumbnail] Generated: ${thumbnailPath}`);
  } catch (error: any) {
    console.warn(`[Thumbnail] Generation failed: ${error.message}`);
    // Thumbnail is optional, don't throw
  }
};

/**
 * Enhanced command execution with timeout
 */
const execWithTimeout = async (
  command: string,
  timeoutMs: number = 300000
): Promise<{ stdout: string; stderr: string }> => {
  console.log(`[Exec] Running: ${command}`);

  try {
    const result = await Promise.race([
      execPromise(command),
      new Promise<never>((_, reject) =>
        setTimeout(
          () => reject(new Error(`Command timeout after ${timeoutMs}ms`)),
          timeoutMs
        )
      ),
    ]);

    console.log(`[Exec] Command completed successfully`);
    return result;
  } catch (error: any) {
    const errorMessage =
      error.stderr || error.stdout || error.message || "Unknown error";
    console.error(`[Exec] Command failed: ${errorMessage}`);
    throw new Error(`Command failed: ${errorMessage}`);
  }
};

/**
 * Generate video title and description for YouTube
 */
const generateYouTubeMetadata = (questionDetails: any, scriptResponse: any) => {
  const title = `${
    questionDetails.title || "Educational Video"
  } - AI Generated Explanation`;

  const description = `
${scriptResponse.description}

üìö This educational video was automatically generated to explain complex concepts through visual animations.

üéØ Topic: ${questionDetails.subject || "Mathematics"}
‚è±Ô∏è Auto-generated content
ü§ñ Created with AI assistance

#Education #Learning #Mathematics #AI #Animation #Tutorial

---
Generated by Adventa AI Education Platform
`.trim();

  const tags = [
    "education",
    "learning",
    "mathematics",
    "tutorial",
    "ai",
    "animation",
    "explanation",
    questionDetails.subject?.toLowerCase(),
    questionDetails.topic?.toLowerCase(),
  ].filter(Boolean);

  return { title, description, tags };
};

// --- Main Worker Logic ---
const worker = new Worker(
  "video-generation",
  async (
    job: Job<{ jobId: string; questionId: number; uploadToYouTube?: boolean }>
  ) => {
    const { jobId, questionId, uploadToYouTube = true } = job.data;
    const TEMP_DIR = path.join(process.cwd(), "temp", jobId);

    console.log(`[Worker] Processing job ${jobId} for question ${questionId}`);
    console.log(`[Worker] Upload to YouTube: ${uploadToYouTube}`);

    try {
      // Clean setup
      await fs.rm(TEMP_DIR, { recursive: true, force: true });
      await fs.mkdir(TEMP_DIR, { recursive: true });

      await prisma.videoGenerationJob.update({
        where: { id: jobId },
        data: { status: "PROCESSING" },
      });

      let jobRecord = await prisma.videoGenerationJob.findUnique({
        where: { id: jobId },
      });
      let lastManimCode = "";

      for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        await job.updateProgress({
          step: `Attempt ${attempt}/${MAX_RETRIES}`,
          attempt,
          max: MAX_RETRIES,
        });

        try {
          // --- Step 1: Get Question Details ---
          const questionDetails = await getQuestionDetailsFromMCP(questionId);
          if (!questionDetails) {
            throw new Error(`Question with ID ${questionId} not found`);
          }

          // --- Step 2: Generate/Debug Manim Script ---
          let scriptResponse;
          if (attempt === 1) {
            console.log(`[Job ${jobId}] Generating Manim script...`);
            scriptResponse = await generateManimScriptWithGemini(
              questionDetails
            );
          } else {
            console.log(`[Job ${jobId}] Debugging failed script...`);
            scriptResponse = await debugManimScriptWithGemini(
              questionDetails,
              lastManimCode,
              jobRecord!.errorMessage || "Unknown error"
            );
          }

          lastManimCode = scriptResponse.manimCode;
          const SCENE_NAME = scriptResponse.className;

          // Update job record
          jobRecord = await prisma.videoGenerationJob.update({
            where: { id: jobId },
            data: {
              manimCode: lastManimCode,
              description: scriptResponse.description,
              retryCount: attempt - 1,
            },
          });

          await job.updateProgress({ step: "Rendering video animation..." });

          // --- Step 3: Render Manim Video ---
          const scriptFileName = `${SCENE_NAME}.py`;
          const scriptPath = path.join(TEMP_DIR, scriptFileName);
          await fs.writeFile(scriptPath, lastManimCode);

          console.log(`[Job ${jobId}] Rendering Manim animation...`);
          const manimOutputDir = path.join(TEMP_DIR, "media");
          const manimCommand = `manim -qm --media_dir "${manimOutputDir}" "${scriptPath}"`;

          await execWithTimeout(manimCommand, 180000); // 3 minutes

          const rawVideoPath = path.join(
            manimOutputDir,
            "videos",
            SCENE_NAME,
            "720p30",
            `${SCENE_NAME}.mp4`
          );

          await validateFile(rawVideoPath, 50000);
          console.log(`[Job ${jobId}] Manim render complete: ${rawVideoPath}`);

          await job.updateProgress({ step: "Generating audio narration..." });

          // --- Step 4: Generate Audio ---
          const audioPath = path.join(TEMP_DIR, `${jobId}_audio.mp3`);
          const escapedDescription = scriptResponse.description.replace(
            /"/g,
            '\\"'
          );
          const audioCommand = `python3 scripts/generate_audio.py "${escapedDescription}" "${audioPath}"`;

          await execWithTimeout(audioCommand, 60000);
          await validateFile(audioPath, 1000);
          console.log(`[Job ${jobId}] Audio generated: ${audioPath}`);

          await job.updateProgress({ step: "Merging video and audio..." });

          // --- Step 5: Merge Video and Audio ---
          const finalVideoPath = path.join(TEMP_DIR, `${jobId}_final.mp4`);
          const mergeCommand = `python3 scripts/merge_media.py "${rawVideoPath}" "${audioPath}" "${finalVideoPath}"`;

          await execWithTimeout(mergeCommand, 120000);
          await validateFile(finalVideoPath, 50000);
          console.log(`[Job ${jobId}] Media merge complete: ${finalVideoPath}`);

          // --- Step 6: Generate Thumbnail ---
          const thumbnailPath = path.join(TEMP_DIR, `${jobId}_thumbnail.jpg`);
          await generateThumbnail(finalVideoPath, thumbnailPath);

          let finalUrl: string;
          let videoId: string | null = null;

          if (uploadToYouTube) {
            await job.updateProgress({ step: "Uploading to YouTube..." });

            // --- Step 7: Upload to YouTube ---
            try {
              const { title, description, tags } = generateYouTubeMetadata(
                questionDetails,
                scriptResponse
              );

              const youtubeResult = await youtubeService.uploadVideo(
                finalVideoPath,
                //@ts-ignore
                {
                  title: title.substring(0, 100), // YouTube title limit
                  description: description.substring(0, 5000), // YouTube description limit
                  tags: tags.slice(0, 15), // YouTube tags limit
                  categoryId: "27", // Education
                  privacyStatus: "unlisted", // Safe default
                  thumbnailPath: await fs
                    .access(thumbnailPath)
                    .then(() => thumbnailPath)
                    .catch(() => undefined),
                }
              );

              finalUrl = youtubeResult.watchUrl;
              videoId = youtubeResult.videoId;

              console.log(
                `[Job ${jobId}] YouTube upload successful: ${finalUrl}`
              );

              // Wait for YouTube processing
              await job.updateProgress({ step: "YouTube processing..." });

              let processingComplete = false;
              let attempts = 0;
              const maxProcessingChecks = 10;

              while (!processingComplete && attempts < maxProcessingChecks) {
                await new Promise((resolve) => setTimeout(resolve, 10000)); // Wait 10 seconds

                try {
                  const status = await youtubeService.checkVideoStatus(
                    youtubeResult.videoId
                  );
                  console.log(
                    `[YouTube] Processing status: ${status.processingStatus}`
                  );

                  if (
                    status.processingStatus === "succeeded" ||
                    status.uploadStatus === "processed"
                  ) {
                    processingComplete = true;
                  } else if (status.processingStatus === "failed") {
                    throw new Error("YouTube processing failed");
                  }
                } catch (statusError: any) {
                  console.warn(
                    `[YouTube] Status check failed: ${statusError.message}`
                  );
                }

                attempts++;
              }
            } catch (youtubeError: any) {
              console.error(
                `[Job ${jobId}] YouTube upload failed: ${youtubeError.message}`
              );

              // Fall back to local file path or throw error based on requirements
              if (
                youtubeError.message.includes("quota") ||
                youtubeError.message.includes("limit")
              ) {
                throw new Error(
                  `YouTube upload failed: ${youtubeError.message}. Please try again later.`
                );
              } else {
                throw youtubeError;
              }
            }
          } else {
            // Keep local file path if not uploading to YouTube
            finalUrl = finalVideoPath;
          }

          // --- Step 8: Update Job Status ---
          await prisma.videoGenerationJob.update({
            where: { id: jobId },
            data: {
              status: "COMPLETED",
              videoUrl: finalUrl,
              //@ts-ignore
              youtubeVideoId: videoId,
              errorMessage: null,
            },
          });

          console.log(
            `[Worker] Job ${jobId} completed successfully: ${finalUrl}`
          );

          return {
            success: true,
            url: finalUrl,
            youtubeVideoId: videoId,
            type: uploadToYouTube ? "youtube" : "local",
          };
        } catch (stepError: any) {
          const errorMessage = stepError.message || stepError.toString();
          console.error(
            `[Job ${jobId}] Attempt ${attempt} failed:`,
            errorMessage
          );

          jobRecord = await prisma.videoGenerationJob.update({
            where: { id: jobId },
            data: {
              errorMessage,
              retryCount: attempt,
            },
          });

          if (attempt >= MAX_RETRIES) {
            throw new Error(
              `Job failed after ${MAX_RETRIES} attempts: ${errorMessage}`
            );
          }

          // Brief delay before retry
          await new Promise((resolve) => setTimeout(resolve, 5000));
        }
      }
    } catch (finalError: any) {
      console.error(
        `[Worker] Job ${jobId} permanently failed:`,
        finalError.message
      );

      await prisma.videoGenerationJob.update({
        where: { id: jobId },
        data: {
          status: "FAILED",
          errorMessage: finalError.message,
        },
      });

      throw finalError;
    } finally {
      // Cleanup
      try {
        console.log(`[Job ${jobId}] Cleaning up: ${TEMP_DIR}`);
        await fs.rm(TEMP_DIR, { recursive: true, force: true });
      } catch (cleanupError: any) {
        console.warn(`[Job ${jobId}] Cleanup warning:`, cleanupError.message);
      }
    }
  },
  {
    connection,
    concurrency: 1,
  }
);

// Enhanced event listeners
worker.on("completed", (job) => {
  console.log(`[Worker] ‚úÖ Job ${job.id} completed successfully`);
});

worker.on("failed", (job, err) => {
  if (job) {
    console.error(`[Worker] ‚ùå Job ${job.id} failed: ${err.message}`);
  }
});

worker.on("progress", (job, progress) => {
  console.log(`[Worker] üìä Job ${job.id} progress:`, progress);
});

// Graceful shutdown
process.on("SIGTERM", async () => {
  console.log("Shutting down worker gracefully...");
  await worker.close();
});

console.log("üöÄ Video generation worker with YouTube upload started!");
