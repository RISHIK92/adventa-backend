import { Worker, Job } from "bullmq";
import { PrismaClient } from "@prisma/client";
import { exec } from "child_process";
import util from "util";
import fs from "fs/promises";
import path from "path";
import "dotenv/config";
import { getQuestionDetailsFromMCP } from "../utils/getQuestionDetailsFromMCP.js";
import { generateManimScriptWithGemini } from "../utils/generateManimScriptWithGemini.js";
import { debugManimScriptWithGemini } from "../utils/debugManimScriptWithGemini.js";

const execPromise = util.promisify(exec);
const prisma = new PrismaClient();

const connection = {
  host: process.env.REDIS_HOST,
  port: parseInt(process.env.REDIS_PORT || "6379"),
};

const MAX_RETRIES = 4;

const uploadToS3 = async (filePath: string, key: string) => {
  console.log(`[Job] Uploading ${filePath} to S3 as ${key}...`);
  // In a real app, use the AWS SDK here.
  // For simulation, we just return a predictable URL.
  return `https://s3.amazonaws.com/${
    process.env.AWS_S3_BUCKET || "your-bucket"
  }/${key}`;
};

// --- The Worker Logic ---

const worker = new Worker(
  "video-generation",
  async (job: Job<{ jobId: string; questionId: number }>) => {
    const { jobId, questionId } = job.data;
    const TEMP_DIR = path.join(process.cwd(), "temp", jobId); // Create a unique temp dir per job

    console.log(`[Worker] Processing job ${jobId} for question ${questionId}`);

    await fs.mkdir(TEMP_DIR, { recursive: true });

    await prisma.videoGenerationJob.update({
      where: { id: jobId },
      data: { status: "PROCESSING" },
    });

    let jobRecord = await prisma.videoGenerationJob.findUnique({
      where: { id: jobId },
    });
    let lastManimCode = "";

    try {
      for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        await job.updateProgress({ attempt, max: MAX_RETRIES });

        try {
          // Step 1: Generate or Debug Script
          let scriptResponse;
          const questionDetails = await getQuestionDetailsFromMCP(questionId);

          if (!questionDetails) {
            throw new Error(
              `Question with ID ${questionId} could not be found. Cannot generate video.`
            );
          }

          if (attempt === 1) {
            scriptResponse = await generateManimScriptWithGemini(
              questionDetails
            );
          } else {
            scriptResponse = await debugManimScriptWithGemini(
              questionDetails,
              lastManimCode,
              jobRecord!.errorMessage || "Unknown error"
            );
          }

          lastManimCode = scriptResponse.manimCode;
          const SCENE_NAME = scriptResponse.className;
          jobRecord = await prisma.videoGenerationJob.update({
            where: { id: jobId },
            data: {
              manimCode: lastManimCode,
              description: scriptResponse.description,
              retryCount: attempt - 1,
            },
          });

          // Step 2: Write script to file
          const scriptFileName = `${jobId}_attempt_${attempt}.py`;
          const scriptPath = path.join(TEMP_DIR, scriptFileName);
          await fs.writeFile(scriptPath, lastManimCode);

          // Step 3: Execute Manim CLI to render the video
          console.log(
            `[Job ${jobId}] Rendering video (Attempt ${attempt}/${MAX_RETRIES})...`
          );
          const manimOutputDir = path.join(TEMP_DIR, "manim_output");
          // FIX: This is the correct command for the integrated Dockerfile
          const manimCommand = `manim -qm --media_dir ${manimOutputDir} ${scriptPath} ${SCENE_NAME}`;

          await execPromise(manimCommand);

          // FIX: Correctly locate the video file generated by Manim.
          const rawVideoPath = path.join(
            manimOutputDir,
            "videos",
            scriptFileName.replace(".py", ""),
            "720p30",
            `${SCENE_NAME}.mp4`
          );
          console.log(`[Job ${jobId}] Manim render successful.`);

          // Step 4: Generate audio from description using the Python script
          const audioPath = path.join(TEMP_DIR, `${jobId}_audio.mp3`);
          await execPromise(
            `python3 scripts/generate_audio.py "${scriptResponse.description}" "${audioPath}"`
          );

          // Step 5: Merge audio and video using the Python script
          // FIX: Use the correct path in the managed TEMP_DIR
          const finalVideoPath = path.join(TEMP_DIR, `${jobId}_final.mp4`);
          // FIX: Call the merge script instead of the placeholder function
          await execPromise(
            `python3 scripts/merge_media.py "${rawVideoPath}" "${audioPath}" "${finalVideoPath}"`
          );

          // Step 6: Upload final video to S3
          const s3Key = `videos/${jobId}/final_video.mp4`;
          const finalS3Url = await uploadToS3(finalVideoPath, s3Key);

          // Step 7: Update job status to COMPLETED
          await prisma.videoGenerationJob.update({
            where: { id: jobId },
            data: {
              status: "COMPLETED",
              videoUrl: finalS3Url,
              errorMessage: null,
            },
          });

          console.log(`[Worker] Job ${jobId} completed successfully.`);
          return { success: true, url: finalS3Url }; // Success, exit loop
        } catch (error: any) {
          const errorMessage = error.stderr || error.stdout || error.message;
          console.error(
            `[Job ${jobId}] Attempt ${attempt} failed:`,
            errorMessage
          );

          jobRecord = await prisma.videoGenerationJob.update({
            where: { id: jobId },
            data: { errorMessage, retryCount: attempt },
          });

          if (attempt >= MAX_RETRIES) {
            throw new Error(`Job failed after ${MAX_RETRIES} attempts.`);
          }
        }
      }
    } catch (finalError: any) {
      // This block catches the final thrown error if all retries fail
      await prisma.videoGenerationJob.update({
        where: { id: jobId },
        data: { status: "FAILED" },
      });
      console.error(`[Worker] Job ${jobId} failed permanently.`);
      throw finalError; // Re-throw to mark the job as failed in BullMQ
    } finally {
      // Step 8: Clean up the temporary directory for this job
      await fs.rm(TEMP_DIR, { recursive: true, force: true });
    }
  },
  { connection }
);

console.log("Video generation worker started.");
worker.on("failed", (job, err) => {
  if (job) {
    console.error(`Job ${job.id} failed with error: ${err.message}`);
  }
});
